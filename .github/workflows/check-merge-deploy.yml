name: Check merge and deploy
on:
  workflow_run:
    workflows: ["Build and test"]
    types: [completed]

  pull_request_target:
    types: [labeled, ready_for_review]

  pull_request_review:
    types: [submitted, edited]

jobs:
  check-merge-deploy:
    name: Check merge and deploy eligibility
    runs-on: ubuntu-18.04

    # Run on push only when the push is to the develop branch
    if: >
      github.event_name != 'workflow_run' ||
        github.event.workflow_run.event != 'push' ||
        github.ref == 'refs/heads/develop'

    env:
      # See comment in validate.yml
      BASH_ENV: ci/env.sh

    steps:
      - name: Configure git
        run: |
          git config --global user.email "bain.william.a+ci@gmail.com"
          git config --global user.name "CI"

      - uses: actions/checkout@v2

      - name: Install system dependencies
        uses: ./.github/actions/install-system-deps
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          dependencies: |
            tree
            jq
            sentry-cli
            unzip

      - name: Resolve inputs
        id: resolve-impl
        uses: actions/github-script@v4
        with:
          script: return await require('./ci/check-merge-deploy/resolve-params.js')({ context, github, core })

      - name: Unpack resolved parameters
        id: resolve
        env:
          VALUES: ${{ steps.resolve-impl.outputs.result }}
        run: |
          jq --null-input --raw-output '
            env.VALUES | fromjson | to_entries[] | "::set-output name=\(.key)::\(.value)"
          '

      - name: Download workflow artifacts
        id: artifact-download
        uses: actions/github-script@v4
        if: steps.resolve.outputs.workflow_run != null
        env:
          WORKSPACE: ${{ github.workspace }}
          WORKFLOW_RUN_ID: ${{ steps.resolve.outputs.workflow_run }}
        with:
          script: return await require('./ci/check-merge-deploy/download.js')({ context, github, core })

      - name: Extract
        if: >
          steps.artifact-download.outcome == 'success' &&
            fromJSON(steps.artifact-download.outputs.result).deploy_path != null
        env:
          DEPLOY_PATH: ${{ fromJSON(steps.artifact-download.outputs.result).deploy_path }}
          BASE_DIR: ${{ github.workspace }}
        run: |
          set -euo pipefail

          file "$DEPLOY_PATH"
          unzip "$DEPLOY_PATH" site.tgz site.revisions.json -d "$BASE_DIR"
          tar -xzf "$BASE_DIR"/site.tgz -C "$BASE_DIR" site

          if [ ! -f "$BASE_DIR/site.revisions.json" ]; then
            echo "::warning ::missing site.revisions.json in archive"
          fi

          tree "$BASE_DIR"

      - name: Fetch refs
        if: steps.resolve.outputs.effective_event == 'pull_request'
        env:
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
          BASE_REF: ${{ steps.resolve.outputs.base_ref }}
          REF: ${{ steps.resolves.outputs.ref }}
        run: |
          ensure-ref() {
            local ref="$1"

            if [ ! -z "$ref" ] && ! git rev-parse "$ref" &> /dev/null; then
              git fetch --no-tags --depth=2 origin "+$ref:$ref"
            fi
          }

          if [ ! -z "$PR_NUMBER" ]; then
            ensure-ref "refs/pull/$PR_NUMBER/merge"
          fi

          ensure-ref "$BASE_REF"
          ensure-ref "$REF"

          echo "Branches:"
          git branch --list -vv

      - name: Evaluate pull request merge eligibility
        id: pr-eval
        if: steps.resolve.outputs.effective_event == 'pull_request'
        env:
          CONCLUSION: ${{ steps.resolve.outputs.conclusion }}
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
          BASE_REF: ${{ steps.resolve.outputs.base_ref }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr="$(bin/ci-evaluate-pr.sh)"

          echo "PR attributes:"
          echo "$pr" | jq -C

          echo "::set-output name=eval::$pr"

          # Add labels before checking for staleness in order to ensure the PR
          # shows up in the maintenance cron job's check

          if [[ "$(echo "$pr" | jq '.pr_may_be_eligible')" == "true" && "$CONCLUSION" == success ]]; then
            if [[ "$(echo "$pr" | jq '.merge_pending_label_present')" == "false" ]]; then
              bin/ci-update-pr-label.sh "$PR_NUMBER" add merge-pending
            fi
          elif [[ "$(echo "$pr" | jq '.merge_pending_label_present')" == "true" ]]; then
            bin/ci-update-pr-label.sh "$PR_NUMBER" del merge-pending
          fi

          # Ensure the revisions used in the job match the revisions found by
          # the PR evaluation

          if [ ! -f "site.revisions.json" ]; then
            echo "No site.revisions.json: treating workflow run as stale"
            echo '::set-output name=stale::true'
            exit
          fi

          base_ref_sha="$(git rev-parse "$BASE_REF")"

          rev_comparison="$(
            jq \
            --null-input \
            --argjson pr_eval "$pr" \
            --arg base_ref_sha "$base_ref_sha" \
            --slurpfile run_entries site.revisions.json \
            '
              (
                if ($run_entries | length) == 1 then
                  $run_entries[0]
                else
                  error("revisions file contains multiple JSON records")
                end
              ) as $run |
              [
                { field: "head_ref", run: $run.head_ref, current: $pr_eval.head_ref },
                { field: "base_ref", run: $run.base_ref, current: $pr_eval.base_ref },
                { field: "head_sha", run: $run.head_sha, current: $pr_eval.head_sha },
                { field: "base_ref_sha", run: $run.base_ref_sha, current: $base_ref_sha },
                { field: "merge sha", run: $run.sha, current: $pr_eval.merge_sha }
              ]
            '
          )"

          echo "::group::Revision comparison"
          echo "$rev_comparison" | jq -C .
          echo "::endgroup::"

          stale_records="$(
            jq \
            --null-input \
            --raw-output \
            --argjson cmp "$rev_comparison" \
            '
              [
                $cmp[] |
                  select(.run != .current) |
                  @json "\(.field) has changed since run (was \(.run), now \(.current))"
              ] |
              join("\n")
            '
          )"

          if [ ! -z "$stale_records" ]; then
            echo "$stale_records"
            echo '::set-output name=stale::true'
            exit
          fi

          # Ensure the fetched merge commit matches the revision found in the
          # PR evaluation

          eval_merge_commit="$(echo "$pr" | jq -r '.merge_commit')"
          effective_merge_commit="$(git rev-parse refs/pull/$PR_NUMBER/merge)"

          if [[ "$eval_merge_commit" != "$effective_merge_commit" ]]; then
            head_ref="$(echo "$pr" | jq -r '.head_ref')"
            echo "PR data is stale (got merge $effective_merge_commit, expected $head_ref merge $merge_commit)"
            echo '::set-output name=stale::true'
            exit
          fi

          echo '::set-output name=stale::false'

      - name: Resolve release version name
        id: release-version
        env:
          PR_EVAL: ${{ steps.pr-eval.outputs.eval }}
          SHA: ${{ steps.resolve.outputs.sha }}
        continue-on-error: true
        run: |
          if [ ! -z "$PR_EVAL" ]; then
            base_ref_sha="$(git rev-parse "$(echo "$PR_EVAL" | jq --raw-output .base_ref)")"
            tree="$(git rev-parse "$(echo "$PR_EVAL" | jq --raw-output .merge_sha)^{tree}")"

            params="$(
              echo "$PR_EVAL" |
              jq --arg base_ref_sha "$base_ref_sha" --arg tree "$tree" '{ head_sha, $base_ref_sha, $tree }'
            )"
          elif [ ! -z "$SHA" ]; then
            tree="$(git rev-parse "$SHA^{tree}")"

            params="$(
              jq --null-input --arg sha "$SHA" --arg tree "$tree" '{ $sha, $tree }'
            )"
          else
            echo "::error ::Missing expected inputs"
            exit 1
          fi

          name="$(echo $params | jq --raw-output -f ci/release-name.jq)"
          echo "::set-output name=name::$name"

          run_name=
          if [ -f site/.test-meta.json ]; then
            run_name="$(jq -r '.release_version' site/.test-meta.json)"
          fi

          if [[ "$name" != "$run_name" ]]; then
            echo "::error ::Unexpected release version from run (got '$run_name', expected '$name')"
            exit 1
          fi

      - name: Push eligible refs
        id: push-refs
        if: >
          steps.resolve.outputs.workflow_run != null &&
            steps.resolve.outputs.conclusion == 'success' &&
            (steps.pr-eval.outcome == 'skipped' || steps.pr-eval.outputs.stale == 'false') &&
            steps.release-version.outcome == 'success'
        env:
          CI_DRY_RUN: "false"
          BASE_DIR: ${{ github.workspace }}
          EFFECTIVE_EVENT: ${{ steps.resolve.outputs.effective_event }}
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
          HEAD_REF: ${{ steps.resolve.outputs.head_ref }}
          BASE_REF: ${{ steps.resolve.outputs.base_ref }}
          PR_EVAL: ${{ steps.pr-eval.outputs.eval }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_BOT_TOKEN: ${{ secrets.GH_BOT_TOKEN }}
          RELEASE_VERSION: ${{ steps.release-version.outputs.name }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        run: bin/ci-push.sh

      - name: "Post-push: Clear pull request merge-pending label"
        if: >
          always() &&
            steps.resolve.outputs.effective_event == 'pull_request' &&
            steps.push-refs.outcome == 'success' &&
            fromJSON(steps.pr-eval.outputs.eval).pr_is_eligible
        continue-on-error: true
        env:
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: bin/ci-update-pr-label.sh "$PR_NUMBER" del merge-pending

      # For workflow_run events there's no obvious indicator of a failure
      # within the pull request, so add a comment
      - name: "Post-run: Add pull request comment on failure"
        if: >
          failure() &&
            steps.resolve.outputs.effective_event == 'pull_request' &&
            github.event_name == 'workflow_run'
        continue-on-error: true
        env:
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          export URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"

          curl --silent --show-error --fail -XPOST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "$GITHUB_API_URL/repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" \
            -d "$(jq -n '{ body: "A [merge/deploy check job] dispatched for this pull request failed.\n\n[merge/deploy check job]: \(env.URL)" }')"
