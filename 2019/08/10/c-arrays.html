<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <link rel="canonical" href="https://wabain.github.io/2019/08/10/c-arrays.html">
  <meta name="version" content="06a89b0ea3aaf009425c17dd803ed368e9e8b9a4+base:62f0ed5f6c297ea9a341c6d669af4291b59d2e03;tree:4abba50dc6989ec6975cb44ba0e838ebe2949b7a">
  <link type="application/atom+xml" rel="alternate" href="https://wabain.github.io/feed.xml" title="William Bain" />

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-51279886-1"></script>
  <script>
    if (location.hostname !== 'wabain.github.io') {
      window['ga-disable-UA-51279886-1'] = true
    }

    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-51279886-1');
    gtag('config', 'UA-51279886-1', { 'transport_type': 'beacon' });
  </script>
  <link type="text/css" rel="stylesheet" href="/home-assets/cs-homepage.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Playfair+Display:400i&display=swap">

  <title>William Bain - Fixing C arrays, four decades later</title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Fixing C arrays, four decades later" />
<meta name="author" content="William Bain" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="One of the greatest challenges in teaching C is the idiosyncratic rules that govern string and array variables. While teachers can delay this hurdle until the second or third week by focusing on programs that use printf with static strings, it can’t be put off much further." />
<meta property="og:description" content="One of the greatest challenges in teaching C is the idiosyncratic rules that govern string and array variables. While teachers can delay this hurdle until the second or third week by focusing on programs that use printf with static strings, it can’t be put off much further." />
<link rel="canonical" href="https://wabain.github.io/2019/08/10/c-arrays.html" />
<meta property="og:url" content="https://wabain.github.io/2019/08/10/c-arrays.html" />
<meta property="og:site_name" content="William Bain" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Fixing C arrays, four decades later" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"William Bain"},"dateModified":"2019-08-10T00:00:00+00:00","datePublished":"2019-08-10T00:00:00+00:00","description":"One of the greatest challenges in teaching C is the idiosyncratic rules that govern string and array variables. While teachers can delay this hurdle until the second or third week by focusing on programs that use printf with static strings, it can’t be put off much further.","headline":"Fixing C arrays, four decades later","mainEntityOfPage":{"@type":"WebPage","@id":"https://wabain.github.io/2019/08/10/c-arrays.html"},"url":"https://wabain.github.io/2019/08/10/c-arrays.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body class="content-longform">
  <div class="grid-base container-underlay"></div>

  <div class="container">
    

<header data-region-id="page-header" class="grid-base grid-header">
  <h1 class="grid-header-title">
    <a href="/" >
      <span class="header-title-text">William Bain</span>
    </a>
  </h1>
  <nav class="grid-header-navbar">
    <ul>
          <li><a href="/projects.html" >Projects</a></li>
          <li><a href="/blog.html" >Blog</a></li>
          <li><a href="/contact.html" >Contact</a></li>
      <li><a href="https://github.com/wabain/" target="_blank">GitHub</a></li>
    </ul>
  </nav>
</header>

    <section data-region-id="primary-content">
      <div class="grid-base grid-post" data-page-meta="Fixing C arrays, four decades later" data-content-longform>
    <div class="grid-post-header">
        <h1>Fixing C arrays, four decades later</h1>
    </div>
    <div class="grid-post-separator"></div>
    <div class="grid-post-meta">
        <div>
            August 10, 2019
        </div>
        <div>
            
            <a href='/tag/language-design'>#language-design</a>
            
            <a href='/tag/c'>#c</a>
            
            <a href='/tag/go'>#go</a>
            
            <a href='/tag/rust'>#rust</a>
            
        </div>
    </div>
    <div class="grid-post-content longform">
        <p>One of the greatest challenges in teaching C is the idiosyncratic rules that govern string and array variables. While teachers can delay this hurdle until the second or third week by focusing on programs that use <code class="language-plaintext highlighter-rouge">printf</code> with static strings, it can’t be put off much further. <!--more--> Any C program that takes command line arguments needs to grapple with how arrays, pointers, and strings relate. The first Google result for “C main” <a href="https://wwwx.cs.unc.edu/~sparkst/howto/cpp_main.php" target="_blank">introduces</a> main functions with a signature that highlights the pointer/array duality:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">);</span>
</code></pre></div></div>

<p>Explaining how to work with the elements of this signature—how to manipulate the string <code class="language-plaintext highlighter-rouge">char* argv</code>, the array <code class="language-plaintext highlighter-rouge">char* argv[]</code>, or the equivalents <code class="language-plaintext highlighter-rouge">char** argv</code> and <code class="language-plaintext highlighter-rouge">char argv[][]</code>—requires teaching not only the runtime semantics of pointer access, but also the particularities of C array variables and the rules that govern their conversion to pointers, an entirely orthogonal concept which is slippery in its own right. When I finally came across an explanation of the rationale for C’s array semantics in <a href="http://www.bell-labs.com/usr/dmr/www/chist.html" target="_blank">a retrospective by Dennis Ritchie</a>, I found that while C’s approach is tied up with the legacy of long-ago PDP-11 code, it also addresses an inherently tricky language design problem that has taken decades to unravel.<sup id="fnref:precedents" role="doc-noteref"><a href="#fn:precedents" class="footnote" rel="footnote">1</a></sup></p>

<p>When Ritchie developed the pre-C variant NB, he allocated two separate areas in storage for an array declaration like <code class="language-plaintext highlighter-rouge">char carray[10]</code>: first, the backing array of ten <code class="language-plaintext highlighter-rouge">char</code>’s, and second a pointer to them, which the variable <code class="language-plaintext highlighter-rouge">carray</code> refers to. The problem with this scheme, it turned out, was that it couldn’t readily be applied to declaring the fields of structured types:</p>

<blockquote>
  <p>For example, the directory entries of early Unix systems might be described in C as</p>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">inumber</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>  </div>

  <p>I wanted the structure not merely to characterize an abstract object but also to describe a collection of bits that might be read from a directory. Where could the compiler hide the pointer to name that the semantics demanded?</p>
</blockquote>

<p>Constrained by the need to mostly preserve the semantics of existing programs, the solution Ritchie hit on was to manifest the pointer at the point of use: only one storage area, for the array content, would be allocated, but an array-type variable in an expression would be treated as a pointer to the first value in the array.</p>

<p>This rule leaves arrays variables, in some ways, as awkward second-class citizens. In proto-C, given arrays defined as <code class="language-plaintext highlighter-rouge">char a[10], b[10]</code> it was possible to write <code class="language-plaintext highlighter-rouge">a = b</code> to point <code class="language-plaintext highlighter-rouge">a</code> to the array defined for <code class="language-plaintext highlighter-rouge">b</code>. In the world after Ritchie’s retrofit, this is problematic: according to the rules, <code class="language-plaintext highlighter-rouge">b</code> should be treated as a pointer, but if <code class="language-plaintext highlighter-rouge">a</code> were treated the same way there would be no coherent way to define assignment to a struct member; in the expression <code class="language-plaintext highlighter-rouge">s.a = b</code>, there is no pointer in the struct to act as the target of the assignment. This restriction manifests in the C89 specification as a <a href="http://port70.net/~nsz/c/c89/c89-draft.html#3.2.2.1" target="_blank">rather inconspicuous clause</a> restricting the applicability of array variable expressions:</p>

<blockquote>
  <p>Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a character string literal used to initialize an array of character type … an lvalue that has type “array of type” is converted to an expression that has type “pointer to type” that points to the initial member of the array object <strong>and is not an lvalue</strong>.</p>
</blockquote>

<p>This excerpt also highlights the other set of restrictions that came with Ritchie’s rule. For the <code class="language-plaintext highlighter-rouge">sizeof</code> operator, the array is not treated as a pointer, since that would leave no way to determine the size of the underlying storage. That means that when switching a variable from a statically sized array to an unsized pointer, the meaning of the sizeof operator changes, a trap that makes it easy to introduce bugs when refactoring. C compounds the problem by introducing the empty array notation, as in <code class="language-plaintext highlighter-rouge">argv[][]</code>, as syntactic sugar for a pointer <code class="language-plaintext highlighter-rouge">**argv</code>, an affordance that Ritchie ultimately concluded “serves as much to confuse the learner as to alert the reader.”</p>

<p>It might seem that, like many of C’s quirks, the array semantics are just an unfortunate legacy. But I think Ritchie was right to insist that, relatively speaking, C’s semantics ultimately provide “a uniform and simple mechanism” for array manipulation. Inspection of how some more recent languages handle arrays reveals a fundamental impedance between modeling arrays as scalar pointers and as sized regions of memory.<sup id="fnref:vla" role="doc-noteref"><a href="#fn:vla" class="footnote" rel="footnote">2</a></sup></p>

<p>Go follows C in allowing for arrays to be declared on the stack or inline within a structure, without extra pointer indirection. Unlike C, it distinguishes clearly between array-typed variables and pointers to arrays, defining array assignment as a value copy which works for both variables and struct members (see below).</p>

<p>However, Go’s uniform treatment of arrays breaks down when moving from statically sized arrays to dynamically sized slices. While they borrow the C-style empty array syntax, Go treats slices as a fundamentally different entity. Assigning the value of one slice to another happens by reference. As with C’s <code class="language-plaintext highlighter-rouge">sizeof</code> operator, this is a common vector for bugs: a simple refactoring to remove a constant bound, if not done carefully, can completely change a program’s semantics.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">aggregate</span> <span class="k">struct</span><span class="p">{</span> <span class="n">i</span> <span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="kt">int</span> <span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="n">aggregate</span>
	<span class="k">var</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="p">[</span><span class="m">4</span><span class="p">]</span><span class="kt">int</span>
	<span class="k">var</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="p">[]</span><span class="kt">int</span>

	<span class="c">// structs: copy by value</span>
	<span class="n">a1</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">5</span>
	<span class="n">a2</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">i</span>
	<span class="n">a1</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v; %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
	<span class="c">// ↪ {[10 0 0 0]}; {[5 0 0 0]}</span>

	<span class="c">// arrays: copy by value</span>
	<span class="n">t1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">5</span>
	<span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span>
	<span class="n">t1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">10</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v; %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
	<span class="c">// ↪ [10 0 0 0]; [5 0 0 0]</span>

	<span class="c">// slices: copy by reference</span>
	<span class="n">s1</span> <span class="o">=</span> <span class="n">t1</span><span class="p">[</span><span class="o">:</span><span class="p">]</span>

	<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">15</span>
	<span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span>
	<span class="n">s1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">20</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v; %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
	<span class="c">// ↪ [20 0 0 0]; [20 0 0 0]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is an alternative, which, to my knowledge, is best exemplified by Rust. Like Go, Rust allows fixed-sized arrays to be stack allocated or directly embedded in an aggregate type. Fundamentally, it treats dynamically sized arrays—including subarrays of a fixed-size array—as ordinary values, with no automatic pointerization. It accomplishes this by restricting how those variables are actually used, forbidding values of types that do not have the <code class="language-plaintext highlighter-rouge">Sized</code> trait from being allocated on the stack. The result is that the alias-instead-of-copy behavior of slices ends up being explicit, and therefore also benefits directly from Rust’s checks against modification of aliased data:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Aggregate</span> <span class="p">{</span>
    <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// structs: copy by value</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a1</span><span class="p">:</span> <span class="n">Aggregate</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a2</span><span class="p">:</span> <span class="n">Aggregate</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

    <span class="n">a1</span><span class="py">.i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">a2</span><span class="py">.i</span> <span class="o">=</span> <span class="n">a1</span><span class="py">.i</span><span class="p">;</span>
    <span class="n">a1</span><span class="py">.i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}; {:?}"</span><span class="p">,</span> <span class="n">a1</span><span class="py">.i</span><span class="p">,</span> <span class="n">a2</span><span class="py">.i</span><span class="p">);</span>
    <span class="c1">// ↪ [10, 0, 0, 0]; [5, 0, 0, 0]</span>

    <span class="c1">// arrays: copy by value</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">t1</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">t2</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>

    <span class="n">t1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span><span class="p">;</span>
    <span class="n">t1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}; {:?}"</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
    <span class="c1">// ↪ [10, 0, 0, 0]; [5, 0, 0, 0]</span>

    <span class="c1">// slices: borrowed reference</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">a1</span><span class="py">.i</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s2</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span><span class="p">[</span><span class="nb">u8</span><span class="p">];</span>

    <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
<span class="c1">//  ------- borrow of `*s1` occurs here</span>
    <span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="c1">//  cannot use `*s1` because it was mutably borrowed</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}, {:?}"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Rust’s approach does come at the expense of an expansion of the language space; beside the restrictions on unsized type usage, both the the type system and the runtime representation of pointers <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/" target="_blank">had to be extended</a> to accommodate these types, the former to handle values with attributes (array size or concrete type) left indeterminate and the latter to allow fat pointers to expose the missing information at runtime. However, it creates semantics that effectively generalize fixed size, dynamically sized, and embedded arrays, with the special-casing visible to the user mostly restricted to the hard constraints of the computer architecture.</p>

<p>After some reflection, I believe Rust’s approach is about the most general possible in a language that exposes array allocation on the stack. Ritchie sacrificed clarity, as well as generality of the assignment operator, for a backwards-compatible and uniform treatment of variable and struct fields. Go sacrifices a uniform treatment of arrays and slices in order to maintain primitives that can be efficiently manipulated. Rust restricts only the use, but not the expression, of patterns that can’t be easily accommodated by conventional stack allocation.</p>

<p>As an academic exercise, it is possible to imagine a fully general array semantics in a language, like Go, that does not have a strict stack/heap distinction. In Go, locally declared variables are already heap-allocated if they could be used by reference outside of the local stack frame. It’s possible to contemplate leveraging this to implement copy-based semantics for dynamically sized slices, with non-pointer assignments copying to the heap and users taking the address of a slice explicitly to assign by reference. The ABI <a href="https://groups.google.com/d/msg/golang-dev/HDLMMYQv7Ak/3z8tL8WxBgAJ" target="_blank">already supports</a> passing pointers for nominally non-pointer values in order to support closures; this could be extended to accommodate heap pointers and concrete sizes to return dynamically sized slices. However, given the impracticality of a language that prioritizes the (potentially much more) expensive access pattern by default, I think the design space Ritchie wrestled with has reached a stable point.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:precedents" role="doc-endnote">
      <p>This is not to make any absolute claims to priority. Ritchie notes that languages contemporary to C, like Pascal and Algol 68, also had problematic array facilities, and no mainstream language in the interim that I am aware of has made the kind of design choices I describe here—not Ada or C++ or D, not reference-centric languages like Java and most scripting languages, and not the mostly immutable functional languages and Lisps. I’d be interested to hear about earlier precedents. <a href="#fnref:precedents" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:vla" role="doc-endnote">
      <p>For the purpose of this post, I’m going to ignore stack-allocated variable-sized arrays, although Ritchie alludes to them briefly and Rust is growing <a href="https://github.com/rust-lang/rust/issues/48055" target="_blank">partial support</a> to match C’s. Suffice it to say that because variably sized allocations can overflow the stack—with their safety depending on non-local factors like function parameters and the use of temporaries—they should be treated as a much more niche tool than array allocation on the heap or static stack allocation. I also consider the optimization complexity that arises from C’s propensity for pointer aliasing, another concern Ritchie highlights, to be more of a problem with pointers than with array semantics. <a href="#fnref:vla" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>
</div>


    </section>
  </div>

  <script defer src="https://browser.sentry-cdn.com/7.53.1/bundle.min.js" integrity="sha384-TAmKuSiw9ilvCDimDNU3n2p9B/TsFLCCBI3zYYxaAwv34hXzH8ghBq/M0SYU/eY9" crossorigin="anonymous"></script>
  <script defer src="/home-assets/cs-homepage.min.js"></script>
</body>
</html>
